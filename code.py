import tkinter as tkfrom tkinter import messageboximport sqlite3import jsonimport osimport randomfrom PIL import Image, ImageTk, ImageDraw, ImageFontfrom dataclasses import dataclassfrom typing import List, Optional, Dict, Tupleimport pymongofrom pymongo import MongoClientfrom urllib.parse import quote_plusimport socketfrom datetime import datetime# Scene images mappingSCENE_IMAGES = {    "start": "images/start.png",    "village_square": "images/village_square.png",    "blacksmith": "images/blacksmith.png",    "buy_sheild": "images/blacksmith.png",    "buy_sword": "images/blacksmith.png",    "dark_forest": "images/dark_forest.png",    "forest_goblin": "images/forest_goblin.png",    "battle_goblin": "images/forest_goblin.png",    "deep_forest": "images/deep_forest.png",    "forest_wolf": "images/forest_wolf.png",    "tame_wolf": "images/forest_wolf.png",    "battle_wolf": "images/forest_wolf.png",    "deep_forest": "images/deep_forest.png",    "cave_entrance": "images/cave.png",    "cave_troll": "images/cave_troll.png",    "bargain_troll": "images/cave_troll.png",    "pay_troll": "images/cave_troll.png",    "cave_treasure": "images/treasure.png",    "take_amulet": "images/treasure.png",    "mountain_path": "images/mountain_path.png",    "demon_outpost": "images/demon_outpost.png",    "battle_demon": "images/demon_outpost.png",    "castle_gates": "images/castle_gates.png",    "guard_riddles": "images/guard_riddles.png",    "throne_room": "images/throne_room.png",    "victory": "images/victory.png",    "game_over": "images/game_over.png"}def load_image_safe(path, default_size=(450, 280)):    """Load an image safely with fallback to a default image"""    try:        img = Image.open(path)        img = img.resize(default_size, Image.LANCZOS)        return ImageTk.PhotoImage(img)    except Exception as e:        print(f"Error loading image {path}: {e}")        # Create a default placeholder image        img = Image.new('RGB', default_size, color='#2c3e50')        draw = ImageDraw.Draw(img)        try:            font = ImageFont.truetype("arial.ttf", 24)        except:            font = ImageFont.load_default()        draw.text((10, 10), "Image not found", fill="white", font=font)        return ImageTk.PhotoImage(img)# Data Classes@dataclassclass Player:    name: str    progress: str    inventory: List[str]    health: int    attack_power: int = 10    defense: int = 5    gold: int = 50    demons_defeated: int = 0    last_saved: datetime = None@dataclass class Scene:    scene_id: str    description: str    choices: List[str]    results: List[str]    items: List[str] = None    enemy: str = None    gold_reward: int = 0    is_riddle: bool = False@dataclassclass Item:    name: str    description: str    effect: str    value: int = 0@dataclassclass Enemy:    name: str    health: int    attack_power: int    loot: List[str] = None    gold_reward: int = 10    is_boss: bool = Falseclass Database:    _instance = None        def __new__(cls):        if cls._instance is None:            cls._instance = super().__new__(cls)            cls._instance.use_mongo = False            cls._instance.setup_databases()        return cls._instance        def __del__(self):        if hasattr(self, 'sqlite_conn'):            self.sqlite_conn.close()        if hasattr(self, 'mongo_client'):            self.mongo_client.close()        def setup_databases(self):        """Setup both MongoDB and SQLite databases"""        # First try to connect to MongoDB        try:            # Replace these with your actual MongoDB Atlas credentials            username = "gamingdivit8"            password = "xW39Q3DtrBCNqdwy"            cluster = "felwinterdb.mongodb.net"            dbname = "felwinter_database"                        # URL encode the username and password            escaped_username = quote_plus(username)            escaped_password = quote_plus(password)                        # Create the MongoDB connection string            mongo_uri = f"mongodb+srv://gamingdivit8:xW39Q3DtrBCNqdwy@felwinterdb.vitlmdb.mongodb.net/?retryWrites=true&w=majority&appName=felwinterdb"                        # Test connection with a short timeout            socket.setdefaulttimeout(5)  # 5 seconds timeout            self.mongo_client = MongoClient(mongo_uri)            self.mongo_db = self.mongo_client[dbname]                        # Test the connection            self.mongo_db.command('ping')            self.use_mongo = True            print("Connected to MongoDB Atlas")            self.initialize_mongo_data()        except Exception as e:            print(f"Could not connect to MongoDB: {e}")            self.use_mongo = False                # Always setup SQLite as fallback        self.sqlite_conn = sqlite3.connect('fantasy_adventure.db')        self.sqlite_conn.row_factory = sqlite3.Row        self.setup_sqlite_tables()                # Initialize data if needed        if not self.use_mongo:            self.initialize_sqlite_data()        def setup_sqlite_tables(self):        """Setup SQLite tables"""        try:            c = self.sqlite_conn.cursor()                        # Create tables            c.execute('''CREATE TABLE IF NOT EXISTS players                        (id INTEGER PRIMARY KEY AUTOINCREMENT,                          name TEXT UNIQUE,                          progress TEXT,                          inventory TEXT,                          health INTEGER,                         attack_power INTEGER,                         defense INTEGER,                         gold INTEGER,                         demons_defeated INTEGER,                         last_saved TEXT)''')                        c.execute('''CREATE TABLE IF NOT EXISTS story                         (id INTEGER PRIMARY KEY AUTOINCREMENT,                           scene TEXT UNIQUE,                           description TEXT,                           choice1 TEXT,                           choice2 TEXT,                           result1 TEXT,                           result2 TEXT,                          items TEXT,                          enemy TEXT,                          gold_reward INTEGER,                          is_riddle BOOLEAN)''')                        c.execute('''CREATE TABLE IF NOT EXISTS items                         (id INTEGER PRIMARY KEY AUTOINCREMENT,                           name TEXT UNIQUE,                           description TEXT,                           effect TEXT,                          value INTEGER)''')                        c.execute('''CREATE TABLE IF NOT EXISTS enemies                         (id INTEGER PRIMARY KEY AUTOINCREMENT,                           name TEXT UNIQUE,                           health INTEGER,                           attack_power INTEGER,                          loot TEXT,                          gold_reward INTEGER,                          is_boss BOOLEAN)''')            c.execute('''CREATE TABLE IF NOT EXISTS riddles                         (id INTEGER PRIMARY KEY AUTOINCREMENT,                          question TEXT UNIQUE,                          answer TEXT)''')            self.sqlite_conn.commit()        except sqlite3.Error as e:            messagebox.showerror("Database Error", f"Failed to setup SQLite database: {e}")        def initialize_sqlite_data(self):        """Initialize SQLite data if empty"""        c = self.sqlite_conn.cursor()                # Insert initial story data if empty        c.execute("SELECT COUNT(*) FROM story")        if c.fetchone()[0] == 0:            story_data = [                ("start", "You wake up in a small village. The elders speak of a Demon King who has been terrorizing the land. They believe you are the chosen one destined to defeat him. Will you accept this quest?", "Accept the quest", "Decline and live peacefully", "village_square", "game_over_peaceful", None, None, 0, False),                ("village_square", "You stand in the village square. The blacksmith offers to upgrade your gear for gold, while the town elder suggests heading to the Dark Forest to begin your journey.", "Visit blacksmith", "Go to Dark Forest", "blacksmith", "dark_forest", None, None, 0, False),                ("blacksmith", "The blacksmith can upgrade your equipment. You currently have 50 gold.", "Buy Sword (+3 ATK, 30g)", "Buy Armor (+3 DEF, 30g)", "buy_sword", "buy_armor", None, None, 0, False),                ("buy_sword", "You purchased a steel sword! It gleams in the sunlight.", "Continue", "", "village_square", "", "steel_sword", None, -30, False),                ("buy_armor", "You purchased iron armor! It feels sturdy.", "Continue", "", "village_square", "", "iron_armor", None, -30, False),                ("dark_forest", "You enter the Dark Forest. The trees loom overhead. You hear growling from both paths.", "Take left path", "Take right path", "forest_goblin", "forest_wolf", None, None, 0, False),                ("forest_goblin", "A goblin jumps out from behind a tree!", "Fight", "Try to sneak past", "battle_goblin", "sneak_goblin", None, "goblin", 0, False),                ("forest_wolf", "A giant wolf blocks your path!", "Fight", "Try to tame it", "battle_wolf", "tame_wolf", None, "wolf", 0, False),                ("sneak_goblin", "You try to sneak past but the goblin spots you!", "Fight", "Run away", "battle_goblin", "dark_forest", None, "goblin", 0, False),                ("tame_wolf", "You attempt to tame the wolf but it attacks!", "Fight", "Run away", "battle_wolf", "dark_forest", None, "wolf", 0, False),                ("battle_goblin", "You defeated the goblin! The path ahead leads deeper into the forest.", "Continue", "", "deep_forest", "", None, None, 0, False),                ("battle_wolf", "You defeated the wolf! The path ahead leads deeper into the forest.", "Continue", "", "deep_forest", "", None, None, 0, False),                ("deep_forest", "The forest grows darker. You see a cave entrance and a path leading to mountains.", "Enter cave", "Go to mountains", "cave_entrance", "mountain_path", None, None, 0, False),                ("cave_entrance", "The cave is dark and damp. You hear strange noises deeper inside.", "Enter deeper", "Leave cave", "cave_troll", "deep_forest", None, None, 0, False),                ("cave_troll", "A massive troll blocks your path!", "Fight", "Try to bargain", "battle_troll", "bargain_troll", None, "troll", 0, False),                ("bargain_troll", "The troll demands all your gold to let you pass!", "Pay (50g)", "Refuse and fight", "pay_troll", "battle_troll", None, None, -50, False),                ("pay_troll", "The troll takes your gold and lets you pass.", "Continue", "", "cave_treasure", "", None, None, 0, False),                ("battle_troll", "You defeated the troll! The cave continues deeper.", "Continue", "", "cave_treasure", "", None, None, 0, False),                ("cave_treasure", "You find a treasure chest! Inside is a magical amulet.", "Take amulet", "Leave it", "take_amulet", "leave_amulet", "magic_amulet", None, 0, False),                ("take_amulet", "You feel the amulet's power coursing through you!", "Continue", "", "demon_outpost", "", None, None, 0, False),                ("leave_amulet", "You leave the amulet and exit the cave.", "Continue", "", "deep_forest", "", None, None, 0, False),                ("mountain_path", "The path winds up the mountain. You see smoke in the distance.", "Follow smoke", "Continue up path", "demon_outpost", "mountain_peak", None, None, 0, False),                ("demon_outpost", "You've found a demon outpost! Several lesser demons guard the entrance to the Demon King's castle.", "Attack outpost", "Sneak past", "battle_demon", "sneak_demon", None, "lesser_demon", 0, False),                ("sneak_demon", "You try to sneak past but are spotted!", "Fight", "Run away", "battle_demon", "mountain_path", None, "lesser_demon", 0, False),                ("battle_demon", "You defeated the demon! The path to the castle is clear.", "Continue", "", "castle_gates", "", None, None, 0, False),                ("mountain_peak", "You reach the mountain peak. The view is breathtaking, but there's nothing here.", "Go back", "", "mountain_path", "", None, None, 0, False),                ("castle_gates", "The massive gates of the Demon King's castle stand before you. Four demon guards block your path.", "Approach guards", "Turn back", "guard_riddles", "demon_outpost", None, None, 0, True),                ("guard_riddles", "The guards challenge you to answer their riddles. Fail even one and you die!", "Accept challenge", "Try to fight them all", "riddle_1", "battle_guards", None, None, 0, False),                ("battle_guards", "You try to fight all four guards at once!", "Fight", "", "battle_all_guards", "", None, "demon_guard", 0, False),                ("battle_all_guards", "You were overwhelmed by the guards and died.", "", "", "game_over", "", None, None, 0, False),                ("riddle_1", "First riddle:", "Answer", "", "riddle_check_1", "", None, None, 0, True),                ("riddle_2", "Second riddle:", "Answer", "", "riddle_check_2", "", None, None, 0, True),                ("riddle_3", "Third riddle:", "Answer", "", "riddle_check_3", "", None, None, 0, True),                ("riddle_4", "Fourth riddle:", "Answer", "", "riddle_check_4", "", None, None, 0, True),                ("riddle_check_1", "Checking first riddle...", "", "", "riddle_2", "game_over", None, None, 0, False),                ("riddle_check_2", "Checking second riddle...", "", "", "riddle_3", "game_over", None, None, 0, False),                ("riddle_check_3", "Checking third riddle...", "", "", "riddle_4", "game_over", None, None, 0, False),                ("riddle_check_4", "Checking fourth riddle...", "", "", "throne_room", "game_over", None, None, 0, False),                ("throne_room", "You enter the throne room. The Demon King rises from his throne!", "Face the Demon King", "Beg for mercy", "battle_demon_king", "game_over_beg", None, None, 0, False),                ("battle_demon_king", "The final battle begins!", "Fight", "", "battle_result_demon_king", "", None, "demon_king", 0, False),                ("game_over", "The guards execute you for failing their challenge.", "", "", "game_over_screen", "", None, None, 0, False),                ("game_over_beg", "The Demon King laughs at your weakness and kills you.", "", "", "game_over_screen", "", None, None, 0, False),                ("game_over_peaceful", "You live a peaceful life, but the kingdom falls to darkness.", "", "", "game_over_screen", "", None, None, 0, False),                ("game_over_screen", "Game Over", "Return to menu", "", "menu", "", None, None, 0, False),                ("victory", "You have defeated the Demon King! The kingdom is saved!", "Return to menu", "", "menu", "", None, None, 0, False)            ]            c.executemany("INSERT INTO story VALUES (NULL, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", story_data)        # Insert initial items if empty        c.execute("SELECT COUNT(*) FROM items")        if c.fetchone()[0] == 0:            item_data = [                ("steel_sword", "Steel Sword", "increase attack", 3),                ("iron_armor", "Iron Armor", "increase defense", 3),                ("magic_amulet", "Magic Amulet", "increase attack and defense", 5),                ("health_potion", "Health Potion", "restore health", 20),                ("gold", "Gold coins", "currency", 0),                ("goblin_ear", "Goblin Ear", "increase defense", 10),                ("wolf_fang", "Wolf Fang", "increase attack", 20),                ("troll_blood", "Troll Blood", "restore health", 100),                ("demon_horn", "Demon Horn", "trophy", 0),                ("strength_potion", "Strength Potion", "increase attack", 5),                ("defense_potion", "Defense Potion", "increase defense", 5),                ("mega_potion", "Mega Potion", "restore health", 50)            ]            c.executemany("INSERT INTO items VALUES (NULL, ?, ?, ?, ?)", item_data)        # Insert initial enemies if empty        c.execute("SELECT COUNT(*) FROM enemies")        if c.fetchone()[0] == 0:            enemy_data = [                ("goblin", 30, 8, "goblin_ear,gold,health_potion", 10, False),                ("wolf", 40, 10, "wolf_fang,gold,health_potion", 15, False),                ("troll", 80, 15, "troll_blood,gold,strength_potion", 25, False),                ("lesser_demon", 60, 18, "demon_horn,gold,defense_potion", 30, False),                ("demon_guard", 100, 20, "demon_horn,gold,mega_potion", 40, False),                ("demon_king", 200, 30, "gold,demon_horn", 100, True)            ]            c.executemany("INSERT INTO enemies VALUES (NULL, ?, ?, ?, ?, ?, ?)", enemy_data)        # Insert riddles if empty        c.execute("SELECT COUNT(*) FROM riddles")        if c.fetchone()[0] == 0:            riddles = [                ("What walks on four legs in the morning, two legs at noon, and three legs in the evening?", "man"),                ("I speak without a mouth and hear without ears. I have no body, but I come alive with wind. What am I?", "echo"),                ("The more you take, the more you leave behind. What am I?", "footsteps"),                ("What has keys but can't open locks?", "piano"),                ("What has to be broken before you can use it?", "egg"),                ("I'm tall when I'm young, and I'm short when I'm old. What am I?", "candle"),                ("What is full of holes but still holds water?", "sponge"),                ("What can you catch but not throw?", "cold"),                ("What goes up but never comes down?", "age"),                ("What can travel around the world while staying in a corner?", "stamp"),                ("What has a head, a tail, is brown, and has no legs?", "penny"),                ("What has many rings but no fingers?", "tree"),                ("The more there is, the less you see. What is it?", "darkness"),                ("What has words but never speaks?", "book"),                ("What gets wetter as it dries?", "towel"),                ("What can you hold in your right hand but not in your left?", "left elbow"),                ("What has a neck but no head?", "bottle"),                ("What can run but never walks, has a mouth but never talks, has a head but never weeps, has a bed but never sleeps?", "river"),                ("What is always in front of you but can't be seen?", "future"),                ("What has cities but no houses, forests but no trees, and water but no fish?", "map")            ]            c.executemany("INSERT INTO riddles VALUES (NULL, ?, ?)", riddles)        self.sqlite_conn.commit()        def initialize_mongo_data(self):        """Initialize MongoDB collections with data if empty"""        if not self.use_mongo:            return                # Initialize story data        if self.mongo_db.story.count_documents({}) == 0:            story_data = [                {"scene": "start", "description": "You wake up in a small village. The elders speak of a Demon King who has been terrorizing the land. They believe you are the chosen one destined to defeat him. Will you accept this quest?", "choice1": "Accept the quest", "choice2": "Decline and live peacefully", "result1": "village_square", "result2": "game_over_peaceful", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": False},                {"scene": "village_square", "description": "You stand in the village square. The blacksmith offers to upgrade your gear for gold, while the town elder suggests heading to the Dark Forest to begin your journey.", "choice1": "Visit blacksmith", "choice2": "Go to Dark Forest", "result1": "blacksmith", "result2": "dark_forest", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": False},                {"scene": "blacksmith", "description": "The blacksmith can upgrade your equipment. You currently have 50 gold.", "choice1": "Buy Sword (+3 ATK, 30g)", "choice2": "Buy Armor (+3 DEF, 30g)", "result1": "buy_sword", "result2": "buy_armor", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": False},                {"scene": "buy_sword", "description": "You purchased a steel sword! It gleams in the sunlight.", "choice1": "Continue", "choice2": "", "result1": "village_square", "result2": "", "items": "steel_sword", "enemy": None, "gold_reward": -30, "is_riddle": False},                {"scene": "buy_armor", "description": "You purchased iron armor! It feels sturdy.", "choice1": "Continue", "choice2": "", "result1": "village_square", "result2": "", "items": "iron_armor", "enemy": None, "gold_reward": -30, "is_riddle": False},                {"scene": "dark_forest", "description": "You enter the Dark Forest. The trees loom overhead. You hear growling from both paths.", "choice1": "Take left path", "choice2": "Take right path", "result1": "forest_goblin", "result2": "forest_wolf", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": False},                {"scene": "forest_goblin", "description": "A goblin jumps out from behind a tree!", "choice1": "Fight", "choice2": "Try to sneak past", "result1": "battle_goblin", "result2": "sneak_goblin", "items": None, "enemy": "goblin", "gold_reward": 0, "is_riddle": False},                {"scene": "forest_wolf", "description": "A giant wolf blocks your path!", "choice1": "Fight", "choice2": "Try to tame it", "result1": "battle_wolf", "result2": "tame_wolf", "items": None, "enemy": "wolf", "gold_reward": 0, "is_riddle": False},                {"scene": "sneak_goblin", "description": "You try to sneak past but the goblin spots you!", "choice1": "Fight", "choice2": "Run away", "result1": "battle_goblin", "result2": "dark_forest", "items": None, "enemy": "goblin", "gold_reward": 0, "is_riddle": False},                {"scene": "tame_wolf", "description": "You attempt to tame the wolf but it attacks!", "choice1": "Fight", "choice2": "Run away", "result1": "battle_wolf", "result2": "dark_forest", "items": None, "enemy": "wolf", "gold_reward": 0, "is_riddle": False},                {"scene": "battle_goblin", "description": "You defeated the goblin! The path ahead leads deeper into the forest.", "choice1": "Continue", "choice2": "", "result1": "deep_forest", "result2": "", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": False},                {"scene": "battle_wolf", "description": "You defeated the wolf! The path ahead leads deeper into the forest.", "choice1": "Continue", "choice2": "", "result1": "deep_forest", "result2": "", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": False},                {"scene": "deep_forest", "description": "The forest grows darker. You see a cave entrance and a path leading to mountains.", "choice1": "Enter cave", "choice2": "Go to mountains", "result1": "cave_entrance", "result2": "mountain_path", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": False},                {"scene": "cave_entrance", "description": "The cave is dark and damp. You hear strange noises deeper inside.", "choice1": "Enter deeper", "choice2": "Leave cave", "result1": "cave_troll", "result2": "deep_forest", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": False},                {"scene": "cave_troll", "description": "A massive troll blocks your path!", "choice1": "Fight", "choice2": "Try to bargain", "result1": "battle_troll", "result2": "bargain_troll", "items": None, "enemy": "troll", "gold_reward": 0, "is_riddle": False},                {"scene": "bargain_troll", "description": "The troll demands all your gold to let you pass!", "choice1": "Pay (50g)", "choice2": "Refuse and fight", "result1": "pay_troll", "result2": "battle_troll", "items": None, "enemy": None, "gold_reward": -50, "is_riddle": False},                {"scene": "pay_troll", "description": "The troll takes your gold and lets you pass.", "choice1": "Continue", "choice2": "", "result1": "cave_treasure", "result2": "", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": False},                {"scene": "battle_troll", "description": "You defeated the troll! The cave continues deeper.", "choice1": "Continue", "choice2": "", "result1": "cave_treasure", "result2": "", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": False},                {"scene": "cave_treasure", "description": "You find a treasure chest! Inside is a magical amulet.", "choice1": "Take amulet", "choice2": "Leave it", "result1": "take_amulet", "result2": "leave_amulet", "items": "magic_amulet", "enemy": None, "gold_reward": 0, "is_riddle": False},                {"scene": "take_amulet", "description": "You feel the amulet's power coursing through you!", "choice1": "Continue", "choice2": "", "result1": "demon_outpost", "result2": "", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": False},                {"scene": "leave_amulet", "description": "You leave the amulet and exit the cave.", "choice1": "Continue", "choice2": "", "result1": "deep_forest", "result2": "", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": False},                {"scene": "mountain_path", "description": "The path winds up the mountain. You see smoke in the distance.", "choice1": "Follow smoke", "choice2": "Continue up path", "result1": "demon_outpost", "result2": "mountain_peak", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": False},                {"scene": "demon_outpost", "description": "You've found a demon outpost! Several lesser demons guard the entrance to the Demon King's castle.", "choice1": "Attack outpost", "choice2": "Sneak past", "result1": "battle_demon", "result2": "sneak_demon", "items": None, "enemy": "lesser_demon", "gold_reward": 0, "is_riddle": False},                {"scene": "sneak_demon", "description": "You try to sneak past but are spotted!", "choice1": "Fight", "choice2": "Run away", "result1": "battle_demon", "result2": "mountain_path", "items": None, "enemy": "lesser_demon", "gold_reward": 0, "is_riddle": False},                {"scene": "battle_demon", "description": "You defeated the demon! The path to the castle is clear.", "choice1": "Continue", "choice2": "", "result1": "castle_gates", "result2": "", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": False},                {"scene": "mountain_peak", "description": "You reach the mountain peak. The view is breathtaking, but there's nothing here.", "choice1": "Go back", "choice2": "", "result1": "mountain_path", "result2": "", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": False},                {"scene": "castle_gates", "description": "The massive gates of the Demon King's castle stand before you. Four demon guards block your path.", "choice1": "Approach guards", "choice2": "Turn back", "result1": "guard_riddles", "result2": "demon_outpost", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": True},                {"scene": "guard_riddles", "description": "The guards challenge you to answer their riddles. Fail even one and you die!", "choice1": "Accept challenge", "choice2": "Try to fight them all", "result1": "riddle_1", "result2": "battle_guards", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": False},                {"scene": "battle_guards", "description": "You try to fight all four guards at once!", "choice1": "Fight", "choice2": "", "result1": "battle_all_guards", "result2": "", "items": None, "enemy": "demon_guard", "gold_reward": 0, "is_riddle": False},                {"scene": "battle_all_guards", "description": "You were overwhelmed by the guards and died.", "choice1": "", "choice2": "", "result1": "game_over", "result2": "", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": False},                {"scene": "riddle_1", "description": "First riddle:", "choice1": "Answer", "choice2": "", "result1": "riddle_check_1", "result2": "", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": True},                {"scene": "riddle_2", "description": "Second riddle:", "choice1": "Answer", "choice2": "", "result1": "riddle_check_2", "result2": "", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": True},                {"scene": "riddle_3", "description": "Third riddle:", "choice1": "Answer", "choice2": "", "result1": "riddle_check_3", "result2": "", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": True},                {"scene": "riddle_4", "description": "Fourth riddle:", "choice1": "Answer", "choice2": "", "result1": "riddle_check_4", "result2": "", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": True},                {"scene": "riddle_check_1", "description": "Checking first riddle...", "choice1": "", "choice2": "", "result1": "riddle_2", "result2": "game_over", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": False},                {"scene": "riddle_check_2", "description": "Checking second riddle...", "choice1": "", "choice2": "", "result1": "riddle_3", "result2": "game_over", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": False},                {"scene": "riddle_check_3", "description": "Checking third riddle...", "choice1": "", "choice2": "", "result1": "riddle_4", "result2": "game_over", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": False},                {"scene": "riddle_check_4", "description": "Checking fourth riddle...", "choice1": "", "choice2": "", "result1": "throne_room", "result2": "game_over", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": False},                {"scene": "throne_room", "description": "You enter the throne room. The Demon King rises from his throne!", "choice1": "Face the Demon King", "choice2": "Beg for mercy", "result1": "battle_demon_king", "result2": "game_over_beg", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": False},                {"scene": "battle_demon_king", "description": "The final battle begins!", "choice1": "Fight", "choice2": "", "result1": "battle_result_demon_king", "result2": "", "items": None, "enemy": "demon_king", "gold_reward": 0, "is_riddle": False},                {"scene": "game_over", "description": "The guards execute you for failing their challenge.", "choice1": "", "choice2": "", "result1": "game_over_screen", "result2": "", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": False},                {"scene": "game_over_beg", "description": "The Demon King laughs at your weakness and kills you.", "choice1": "", "choice2": "", "result1": "game_over_screen", "result2": "", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": False},                {"scene": "game_over_peaceful", "description": "You live a peaceful life, but the kingdom falls to darkness.", "choice1": "", "choice2": "", "result1": "game_over_screen", "result2": "", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": False},                {"scene": "game_over_screen", "description": "Game Over", "choice1": "Return to menu", "choice2": "", "result1": "menu", "result2": "", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": False},                {"scene": "victory", "description": "You have defeated the Demon King! The kingdom is saved!", "choice1": "Return to menu", "choice2": "", "result1": "menu", "result2": "", "items": None, "enemy": None, "gold_reward": 0, "is_riddle": False}            ]            self.mongo_db.story.insert_many(story_data)                # Initialize items        if self.mongo_db.items.count_documents({}) == 0:            item_data = [                {"name": "steel_sword", "description": "Steel Sword", "effect": "increase attack", "value": 3},                {"name": "iron_armor", "description": "Iron Armor", "effect": "increase defense", "value": 3},                {"name": "magic_amulet", "description": "Magic Amulet", "effect": "increase attack and defense", "value": 5},                {"name": "health_potion", "description": "Health Potion", "effect": "restore health", "value": 20},                {"name": "gold", "description": "Gold coins", "effect": "currency", "value": 0},                {"name": "goblin_ear", "description": "Goblin Ear", "effect": "increase defense", "value": 10},                {"name": "wolf_fang", "description": "Wolf Fang", "effect": "increase attack", "value": 20},                {"name": "troll_blood", "description": "Troll Blood", "effect": "restore health", "value": 100},                {"name": "demon_horn", "description": "Demon Horn", "effect": "trophy", "value": 0},                {"name": "strength_potion", "description": "Strength Potion", "effect": "increase attack", "value": 5},                {"name": "defense_potion", "description": "Defense Potion", "effect": "increase defense", "value": 5},                {"name": "mega_potion", "description": "Mega Potion", "effect": "restore health", "value": 50}            ]            self.mongo_db.items.insert_many(item_data)                # Initialize enemies        if self.mongo_db.enemies.count_documents({}) == 0:            enemy_data = [                {"name": "goblin", "health": 30, "attack_power": 8, "loot": ["goblin_ear", "gold", "health_potion"], "gold_reward": 10, "is_boss": False},                {"name": "wolf", "health": 40, "attack_power": 10, "loot": ["wolf_fang", "gold", "health_potion"], "gold_reward": 15, "is_boss": False},                {"name": "troll", "health": 80, "attack_power": 15, "loot": ["troll_blood", "gold", "strength_potion"], "gold_reward": 25, "is_boss": False},                {"name": "lesser_demon", "health": 60, "attack_power": 18, "loot": ["demon_horn", "gold", "defense_potion"], "gold_reward": 30, "is_boss": False},                {"name": "demon_guard", "health": 100, "attack_power": 20, "loot": ["demon_horn", "gold", "mega_potion"], "gold_reward": 40, "is_boss": False},                {"name": "demon_king", "health": 200, "attack_power": 30, "loot": ["gold", "demon_horn"], "gold_reward": 100, "is_boss": True}            ]            self.mongo_db.enemies.insert_many(enemy_data)                # Initialize riddles        if self.mongo_db.riddles.count_documents({}) == 0:            riddle_data = [                {"question": "What walks on four legs in the morning, two legs at noon, and three legs in the evening?", "answer": "man"},                {"question": "I speak without a mouth and hear without ears. I have no body, but I come alive with wind. What am I?", "answer": "echo"},                {"question": "The more you take, the more you leave behind. What am I?", "answer": "footsteps"},                {"question": "What has keys but can't open locks?", "answer": "piano"},                {"question": "What has to be broken before you can use it?", "answer": "egg"},                {"question": "I'm tall when I'm young, and I'm short when I'm old. What am I?", "answer": "candle"},                {"question": "What is full of holes but still holds water?", "answer": "sponge"},                {"question": "What can you catch but not throw?", "answer": "cold"},                {"question": "What goes up but never comes down?", "answer": "age"},                {"question": "What can travel around the world while staying in a corner?", "answer": "stamp"},                {"question": "What has a head, a tail, is brown, and has no legs?", "answer": "penny"},                {"question": "What has many rings but no fingers?", "answer": "tree"},                {"question": "The more there is, the less you see. What is it?", "answer": "darkness"},                {"question": "What has words but never speaks?", "answer": "book"},                {"question": "What gets wetter as it dries?", "answer": "towel"},                {"question": "What can you hold in your right hand but not in your left?", "answer": "left elbow"},                {"question": "What has a neck but no head?", "answer": "bottle"},                {"question": "What can run but never walks, has a mouth but never talks, has a head but never weeps, has a bed but never sleeps?", "answer": "river"},                {"question": "What is always in front of you but can't be seen?", "answer": "future"},                {"question": "What has cities but no houses, forests but no trees, and water but no fish?", "answer": "map"}            ]            self.mongo_db.riddles.insert_many(riddle_data)        def get_random_riddle(self) -> Tuple[str, str]:        """Get a random riddle from the database"""        if self.use_mongo:            riddle = self.mongo_db.riddles.aggregate([{"$sample": {"size": 1}}]).next()            return (riddle["question"], riddle["answer"])        else:            c = self.sqlite_conn.cursor()            c.execute("SELECT * FROM riddles ORDER BY RANDOM() LIMIT 1")            result = c.fetchone()            return (result['question'], result['answer']) if result else ("", "")    def save_player(self, player: Player) -> bool:        try:            player_data = {                "name": player.name,                "progress": player.progress,                "inventory": player.inventory,                "health": player.health,                "attack_power": player.attack_power,                "defense": player.defense,                "gold": player.gold,                "demons_defeated": player.demons_defeated,                "last_saved": datetime.now()            }                        if self.use_mongo:                self.mongo_db.players.update_one(                    {"name": player.name},                    {"$set": player_data},                    upsert=True                )            else:                c = self.sqlite_conn.cursor()                c.execute("""INSERT OR REPLACE INTO players                             (name, progress, inventory, health, attack_power, defense, gold, demons_defeated, last_saved)                             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)""",                         (player.name, player.progress, json.dumps(player.inventory),                           player.health, player.attack_power, player.defense,                           player.gold, player.demons_defeated, datetime.now().isoformat()))                self.sqlite_conn.commit()            return True        except Exception as e:            messagebox.showerror("Save Error", f"Failed to save player: {e}")            return False    def load_player(self, name: str) -> Optional[Player]:        try:            if self.use_mongo:                result = self.mongo_db.players.find_one({"name": name})                if result:                    return Player(                        name=result['name'],                        progress=result['progress'],                        inventory=result['inventory'],                        health=result['health'],                        attack_power=result.get('attack_power', 10),                        defense=result.get('defense', 5),                        gold=result.get('gold', 50),                        demons_defeated=result.get('demons_defeated', 0),                        last_saved=result.get('last_saved')                    )            else:                c = self.sqlite_conn.cursor()                c.execute("SELECT * FROM players WHERE name=?", (name,))                result = c.fetchone()                if result:                    last_saved = datetime.fromisoformat(result['last_saved']) if result['last_saved'] else None                    return Player(                        name=result['name'],                        progress=result['progress'],                        inventory=json.loads(result['inventory']),                        health=result['health'],                        attack_power=result.get('attack_power', 10),                        defense=result.get('defense', 5),                        gold=result.get('gold', 50),                        demons_defeated=result.get('demons_defeated', 0),                        last_saved=last_saved                    )            return None        except Exception as e:            messagebox.showerror("Load Error", f"Failed to load player: {e}")            return None    def load_scene(self, scene_id: str) -> Optional[Scene]:        try:            if self.use_mongo:                result = self.mongo_db.story.find_one({"scene": scene_id})                if result:                    items = result.get('items')                    if items and isinstance(items, str):                        items = items.split(',')                    return Scene(                        scene_id=result['scene'],                        description=result['description'],                        choices=[result['choice1'], result['choice2']],                        results=[result['result1'], result['result2']],                        items=items,                        enemy=result.get('enemy'),                        gold_reward=result.get('gold_reward', 0),                        is_riddle=result.get('is_riddle', False)                    )            else:                c = self.sqlite_conn.cursor()                c.execute("SELECT * FROM story WHERE scene=?", (scene_id,))                result = c.fetchone()                if result:                    items = result['items'].split(',') if result['items'] else None                    return Scene(                        scene_id=result['scene'],                        description=result['description'],                        choices=[result['choice1'], result['choice2']],                        results=[result['result1'], result['result2']],                        items=items,                        enemy=result['enemy'],                        gold_reward=result['gold_reward'],                        is_riddle=bool(result['is_riddle'])                    )            return None        except Exception as e:            messagebox.showerror("Scene Error", f"Failed to load scene: {e}")            return None    def load_item(self, name: str) -> Optional[Item]:        try:            if self.use_mongo:                result = self.mongo_db.items.find_one({"name": name})                if result:                    return Item(                        name=result['name'],                        description=result['description'],                        effect=result['effect'],                        value=result.get('value', 0)                    )            else:                c = self.sqlite_conn.cursor()                c.execute("SELECT * FROM items WHERE name=?", (name,))                result = c.fetchone()                if result:                    return Item(                        name=result['name'],                        description=result['description'],                        effect=result['effect'],                        value=result['value']                    )            return None        except Exception as e:            messagebox.showerror("Item Error", f"Failed to load item: {e}")            return None    def load_enemy(self, name: str) -> Optional[Enemy]:        try:            if self.use_mongo:                result = self.mongo_db.enemies.find_one({"name": name})                if result:                    loot = result.get('loot')                    if loot and isinstance(loot, str):                        loot = loot.split(',')                    return Enemy(                        name=result['name'],                        health=result['health'],                        attack_power=result['attack_power'],                        loot=loot,                        gold_reward=result.get('gold_reward', 10),                        is_boss=result.get('is_boss', False)                    )            else:                c = self.sqlite_conn.cursor()                c.execute("SELECT * FROM enemies WHERE name=?", (name,))                result = c.fetchone()                if result:                    loot = result['loot'].split(',') if result['loot'] else None                    return Enemy(                        name=result['name'],                        health=result['health'],                        attack_power=result['attack_power'],                        loot=loot,                        gold_reward=result['gold_reward'],                        is_boss=bool(result['is_boss'])                    )            return None        except Exception as e:            messagebox.showerror("Enemy Error", f"Failed to load enemy: {e}")            return None# Main Game Windowclass GameWindow:    def __init__(self, root):        self.root = root        self.root.title("Demon King Adventure")        self.root.geometry("900x700")        self.root.minsize(800, 600)        self.root.configure(bg="#2c3e50")                # Custom font styles        self.title_font = ("Helvetica", 24, "bold")        self.button_font = ("Helvetica", 12)        self.text_font = ("Helvetica", 11)        self.status_font = ("Helvetica", 10, "bold")                # Initialize database        self.db = Database()                # Main container frame with modern styling        self.main_frame = tk.Frame(root, bg="#2c3e50", padx=20, pady=20)        self.main_frame.pack(fill=tk.BOTH, expand=True)                # Initialize game state        self.current_player = Player(            name="",            progress="start",            inventory=[],            health=100,            gold=50,            demons_defeated=0        )        self.current_enemy = None        self.current_items = []        self.current_riddle = ("", "")        self.riddle_attempts = 0        self.inventory_window = None        self.current_enemy_number = None  # Store the enemy's number for battles                # Create status bar with modern styling        self.status_frame = tk.Frame(root, bg="#34495e", bd=1, relief=tk.SUNKEN)        self.status_frame.pack(fill=tk.X, side=tk.BOTTOM)                # Show start menu        self.show_menu()    def clear_frame(self):        """Clear all widgets from main frame"""        for widget in self.main_frame.winfo_children():            widget.destroy()    def update_status(self):        """Update the status bar with current player stats"""        # Clear status frame        for widget in self.status_frame.winfo_children():            widget.destroy()                # Health        health_label = tk.Label(            self.status_frame,             text=f"? {self.current_player.health}",            fg="#e74c3c" if self.current_player.health < 30 else "#ecf0f1",            bg="#34495e",            font=self.status_font,            padx=10        )        health_label.pack(side=tk.LEFT)                # Attack        tk.Label(            self.status_frame,             text=f"? {self.current_player.attack_power}",            fg="#ecf0f1",            bg="#34495e",            font=self.status_font,            padx=10        ).pack(side=tk.LEFT)                # Defense        tk.Label(            self.status_frame,             text=f"?? {self.current_player.defense}",            fg="#ecf0f1",            bg="#34495e",            font=self.status_font,            padx=10        ).pack(side=tk.LEFT)                # Gold        tk.Label(            self.status_frame,             text=f"?? {self.current_player.gold}",            fg="#f1c40f",            bg="#34495e",            font=self.status_font,            padx=10        ).pack(side=tk.LEFT)                # Demons Defeated        tk.Label(            self.status_frame,             text=f"?? {self.current_player.demons_defeated}",            fg="#ecf0f1",            bg="#34495e",            font=self.status_font,            padx=10        ).pack(side=tk.LEFT)                # Database indicator        db_indicator = tk.Label(            self.status_frame,            text="MongoDB" if self.db.use_mongo else "SQLite",            fg="#2ecc71" if self.db.use_mongo else "#e67e22",            bg="#34495e",            font=self.status_font,            padx=10        )        db_indicator.pack(side=tk.LEFT)                # Inventory button        inv_btn = tk.Button(            self.status_frame,            text="Inventory",            command=self.show_inventory,            bg="#3498db",            fg="white",            activebackground="#2980b9",            activeforeground="white",            relief=tk.FLAT,            font=self.status_font,            padx=10        )        inv_btn.pack(side=tk.RIGHT, padx=5)    def show_inventory(self):        """Display the inventory in a styled window"""        if self.inventory_window and self.inventory_window.winfo_exists():            self.inventory_window.lift()            return        self.inventory_window = tk.Toplevel(self.root)        self.inventory_window.title("Inventory")        self.inventory_window.geometry("450x550")        self.inventory_window.configure(bg="#2c3e50")        self.inventory_window.protocol("WM_DELETE_WINDOW", self.close_inventory)                # Inventory title        title_frame = tk.Frame(self.inventory_window, bg="#2c3e50")        title_frame.pack(pady=(15, 10), fill=tk.X)                tk.Label(            title_frame,            text="INVENTORY",            font=self.title_font,            fg="#ecf0f1",            bg="#2c3e50"        ).pack()                # Item count display        item_count = len(self.current_player.inventory)        tk.Label(            title_frame,            text=f"{item_count} item{'s' if item_count != 1 else ''}",            font=("Helvetica", 10),            fg="#bdc3c7",            bg="#2c3e50"        ).pack()                # Canvas for scrollable area        canvas = tk.Canvas(            self.inventory_window,            bg="#34495e",            highlightthickness=0        )        scrollbar = tk.Scrollbar(            self.inventory_window,            orient="vertical",            command=canvas.yview,            bg="#2c3e50",            troughcolor="#2c3e50",            activebackground="#3498db"        )        scrollable_frame = tk.Frame(canvas, bg="#34495e")                scrollable_frame.bind(            "<Configure>",            lambda e: canvas.configure(                scrollregion=canvas.bbox("all")            )        )                canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")        canvas.configure(yscrollcommand=scrollbar.set)                canvas.pack(side="left", fill="both", expand=True, padx=10, pady=10)        scrollbar.pack(side="right", fill="y", padx=(0, 10), pady=10)                # Display items        if not self.current_player.inventory:            empty_label = tk.Label(                scrollable_frame,                text="Your inventory is empty!",                font=self.text_font,                fg="#bdc3c7",                bg="#34495e",                pady=20            )            empty_label.pack(fill=tk.X)        else:            # Count items            item_counts = {}            for item_name in self.current_player.inventory:                item_counts[item_name] = item_counts.get(item_name, 0) + 1                        # Display each unique item with count            for item_name, count in sorted(item_counts.items()):                item = self.db.load_item(item_name)                if not item:                    continue                                # Determine item color based on type                if "potion" in item.name.lower():                    item_color = "#1abc9c"  # Teal for potions                elif any(x in item.effect for x in ["attack", "defense"]):                    item_color = "#e67e22"  # Orange for equipment                else:                    item_color = "#bdc3c7"  # Gray for trophies                                item_frame = tk.Frame(                    scrollable_frame,                    bg="#34495e",                    bd=1,                    relief=tk.RAISED,                    padx=10,                    pady=10                )                item_frame.pack(fill=tk.X, padx=5, pady=5)                                # Item info                tk.Label(                    item_frame,                    text=f"{item.name} x{count}",                    font=("Helvetica", 12, "bold"),                    fg=item_color,                    bg="#34495e",                    anchor="w"                ).pack(fill=tk.X)                                tk.Label(                    item_frame,                    text=item.description,                    font=self.text_font,                    fg="#ecf0f1",                    bg="#34495e",                    anchor="w",                    wraplength=350                ).pack(fill=tk.X)                                # Use button for consumable items                if item.effect in ["restore health", "increase attack", "increase defense"]:                    use_btn = tk.Button(                        item_frame,                        text="USE",                        command=lambda i=item: self.use_item(i),                        bg="#3498db",                        fg="white",                        activebackground="#2980b9",                        activeforeground="white",                        relief=tk.FLAT,                        font=("Helvetica", 10, "bold"),                        padx=10                    )                    use_btn.pack(side=tk.RIGHT, padx=5)        def close_inventory(self):        """Properly close inventory window"""        if self.inventory_window:            self.inventory_window.destroy()            self.inventory_window = None        def use_item(self, item: Item):        """Use a consumable item from inventory"""        if item.name not in self.current_player.inventory:            messagebox.showerror("Error", "Item not found in inventory!")            return                # Apply effect        if item.effect == "restore health":            self.current_player.health = min(100, self.current_player.health + item.value)            message = f"Used {item.name}! Restored {item.value} health."        elif item.effect == "increase attack":            self.current_player.attack_power += item.value            message = f"Used {item.name}! +{item.value} attack power."        elif item.effect == "increase defense":            self.current_player.defense += item.value            message = f"Used {item.name}! +{item.value} defense."        else:            messagebox.showinfo("Info", f"{item.name} cannot be used directly.")            return                # Remove item from inventory        self.current_player.inventory.remove(item.name)                # Update status and inventory        self.update_status()        if self.inventory_window and self.inventory_window.winfo_exists():            self.show_inventory()  # Refresh inventory window                messagebox.showinfo("Item Used", message)        self.db.save_player(self.current_player)    def show_menu(self):        """Display the main menu with modern styling"""        self.clear_frame()                # Title with gradient effect        title_frame = tk.Frame(self.main_frame, bg="#2c3e50")        title_frame.pack(pady=(20, 40))                tk.Label(            title_frame,             text="DEMON KING ADVENTURE",             font=self.title_font,            fg="#ecf0f1",            bg="#2c3e50"        ).pack()                # Subtitle        tk.Label(            title_frame,            text="A Text Adventure Game",            font=("Helvetica", 14),            fg="#bdc3c7",            bg="#2c3e50"        ).pack(pady=(5, 0))                # Name entry with modern styling        name_frame = tk.Frame(self.main_frame, bg="#2c3e50")        name_frame.pack(pady=20)                tk.Label(            name_frame,             text="Enter your name:",             font=self.text_font,            fg="#ecf0f1",            bg="#2c3e50"        ).pack(side=tk.LEFT, padx=5)                self.name_entry = tk.Entry(            name_frame,            font=self.text_font,            bg="#ecf0f1",            fg="#2c3e50",            insertbackground="#2c3e50",            relief=tk.FLAT,            width=20        )        self.name_entry.pack(side=tk.LEFT, padx=5)                # Buttons with modern styling        button_frame = tk.Frame(self.main_frame, bg="#2c3e50")        button_frame.pack(pady=30)                button_style = {            "font": self.button_font,            "width": 15,            "height": 2,            "bg": "#3498db",            "fg": "white",            "activebackground": "#2980b9",            "activeforeground": "white",            "relief": tk.FLAT,            "bd": 0        }                new_game_btn = tk.Button(            button_frame,             text="New Game",             command=self.start_new_game,            **button_style        )        new_game_btn.pack(side=tk.LEFT, padx=15, pady=5)                load_game_btn = tk.Button(            button_frame,             text="Load Game",             command=self.load_game,            **button_style        )        load_game_btn.pack(side=tk.LEFT, padx=15, pady=5)                quit_btn = tk.Button(            button_frame,             text="Quit",             command=self.root.quit,            bg="#e74c3c",            activebackground="#c0392b",            **{k:v for k,v in button_style.items() if k not in ['bg', 'activebackground']}        )        quit_btn.pack(side=tk.LEFT, padx=15, pady=5)    def start_new_game(self):        """Start a new game with the entered name"""        name = self.name_entry.get().strip()        if not name:            messagebox.showwarning("Input Error", "Please enter your name")            return                self.current_player = Player(            name=name,            progress="start",            inventory=[],            health=100,            gold=50,            demons_defeated=0        )        self.display_scene("start")    def load_game(self):        """Load a saved game"""        name = self.name_entry.get().strip()        if not name:            messagebox.showwarning("Input Error", "Please enter your name")            return                player = self.db.load_player(name)        if player:            self.current_player = player            self.display_scene(player.progress)        else:            messagebox.showinfo("Load Failed", f"No saved game found for {name}")    def display_scene(self, scene_id: str):        """Display a game scene with modern styling"""        self.clear_frame()                # Scene content frame        content_frame = tk.Frame(            self.main_frame,            bg="#34495e",            bd=2,            relief=tk.RAISED,            padx=15,            pady=15        )        content_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)                # Scene image        try:            img_path = SCENE_IMAGES.get(scene_id, "images/default.png")            self.scene_image = load_image_safe(img_path)                        image_frame = tk.Frame(content_frame, bg="#34495e")            image_frame.pack(pady=(0, 15))                        image_label = tk.Label(                image_frame,                image=self.scene_image,                bd=0            )            image_label.pack()        except Exception as e:            print(f"Error displaying image: {e}")            image_label = tk.Label(                content_frame,                 text=f"Scene: {scene_id.replace('_', ' ').title()}",                bg="#2c3e50",                fg="#ecf0f1",                width=60,                height=10,                font=self.text_font            )            image_label.pack(pady=10)                # Scene description with scrollbar        text_frame = tk.Frame(content_frame, bg="#34495e")        text_frame.pack(fill=tk.BOTH, expand=True)                text_scroll = tk.Scrollbar(text_frame)        text_scroll.pack(side=tk.RIGHT, fill=tk.Y)                text_display = tk.Text(            text_frame,            height=8,            width=60,            wrap=tk.WORD,            font=self.text_font,            bg="#2c3e50",            fg="#ecf0f1",            insertbackground="#ecf0f1",            padx=10,            pady=10,            bd=0,            yscrollcommand=text_scroll.set        )        text_display.pack(fill=tk.BOTH, expand=True)        text_scroll.config(command=text_display.yview)                # Update player progress        self.current_player.progress = scene_id        scene = self.db.load_scene(scene_id)                if not scene:            messagebox.showerror("Error", f"Scene {scene_id} not found")            return                # Handle special scenes        if scene_id.startswith("riddle_"):            self.handle_riddle_scene(scene)            return                # Only load a NEW enemy if we're not in the middle of a battle        if scene.enemy and (not self.current_enemy or self.current_enemy.name != scene.enemy):            self.current_enemy = self.db.load_enemy(scene.enemy)            self.current_enemy_number = None  # Reset enemy number when facing new enemy                description = scene.description                # Handle special scenes        if self.current_enemy:            description += f"\n\nEnemy: {self.current_enemy.name}\n"            description += f"Health: {self.current_enemy.health}\n"            description += f"Attack: {self.current_enemy.attack_power}"            if self.current_enemy.is_boss:                description += "\n\nThis is the FINAL BOSS!"                elif scene.items:            # Scene with items to collect            for item_name in scene.items:                item = self.db.load_item(item_name)                if item:                    self.current_player.inventory.append(item.name)                    # Apply item effects                    if "attack" in item.effect and "defense" in item.effect:                        self.current_player.attack_power += item.value                        self.current_player.defense += item.value                        description += f"\n\nYou gained {item.name} (+{item.value} attack and defense)!"                    elif "attack" in item.effect:                        self.current_player.attack_power += item.value                        description += f"\n\nYou gained {item.name} (+{item.value} attack)!"                    elif "defense" in item.effect:                        self.current_player.defense += item.value                        description += f"\n\nYou gained {item.name} (+{item.value} defense)!"                    elif "health" in item.effect:                        self.current_player.health = min(100, self.current_player.health + item.value)                        description += f"\n\nYou used {item.name} and restored {item.value} health!"                # Handle gold rewards        if scene.gold_reward > 0:            self.current_player.gold += scene.gold_reward            description += f"\n\nYou found {scene.gold_reward} gold!"        elif scene.gold_reward < 0:            description += f"\n\nYou spent {-scene.gold_reward} gold."                text_display.insert(tk.END, description)        text_display.config(state=tk.DISABLED)                # Create choice buttons        button_frame = tk.Frame(content_frame, bg="#34495e")        button_frame.pack(pady=20)                # Safely get choices and results        choices = scene.choices if scene.choices else ["", ""]        results = scene.results if scene.results else ["", ""]                # Create buttons only for valid choices        for i in range(2):            if i < len(choices) and choices[i]:  # Only create button if choice exists                btn = tk.Button(                    button_frame,                     text=choices[i],                     command=lambda r=results[i]: self.process_choice(r) if r else None,                    bg="#3498db",                    fg="white",                    activebackground="#2980b9",                    activeforeground="white",                    relief=tk.FLAT,                    font=self.button_font,                    width=20,                    height=2                )                btn.pack(side=tk.LEFT, padx=10, pady=5)                # Add menu button        menu_btn = tk.Button(            button_frame,            text="Main Menu",            command=self.show_menu,            bg="#e74c3c",            fg="white",            activebackground="#c0392b",            activeforeground="white",            relief=tk.FLAT,            font=self.button_font,            width=20,            height=2        )        menu_btn.pack(side=tk.LEFT, padx=10, pady=5)                # Update status bar        self.update_status()                # Auto-save progress        self.db.save_player(self.current_player)    def handle_riddle_scene(self, scene: Scene):        """Handle the riddle challenge scenes"""        self.clear_frame()                # Scene content frame        content_frame = tk.Frame(            self.main_frame,            bg="#34495e",            bd=2,            relief=tk.RAISED,            padx=15,            pady=15        )        content_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)                # Get a new riddle for each riddle scene        if not self.current_riddle[0] or self.riddle_attempts > 0:            self.current_riddle = self.db.get_random_riddle()            self.riddle_attempts = 0                # Scene description        text_frame = tk.Frame(content_frame, bg="#34495e")        text_frame.pack(fill=tk.BOTH, expand=True)                text_display = tk.Text(            text_frame,            height=10,            width=60,            wrap=tk.WORD,            font=self.text_font,            bg="#2c3e50",            fg="#ecf0f1",            insertbackground="#ecf0f1",            padx=10,            pady=10,            bd=0        )        text_display.pack(fill=tk.BOTH, expand=True)                description = f"{scene.description}\n\n{self.current_riddle[0]}"        text_display.insert(tk.END, description)        text_display.config(state=tk.DISABLED)                # Answer entry        answer_frame = tk.Frame(content_frame, bg="#34495e")        answer_frame.pack(pady=10)                tk.Label(            answer_frame,            text="Your answer:",            font=self.text_font,            fg="#ecf0f1",            bg="#34495e"        ).pack(side=tk.LEFT, padx=5)                self.answer_entry = tk.Entry(            answer_frame,            font=self.text_font,            bg="#ecf0f1",            fg="#2c3e50",            insertbackground="#2c3e50",            relief=tk.FLAT        )        self.answer_entry.pack(side=tk.LEFT, padx=5)                # Submit button        button_frame = tk.Frame(content_frame, bg="#34495e")        button_frame.pack(pady=20)                submit_btn = tk.Button(            button_frame,             text="Submit Answer",             command=lambda: self.check_riddle_answer(scene),            bg="#3498db",            fg="white",            activebackground="#2980b9",            activeforeground="white",            relief=tk.FLAT,            font=self.button_font,            width=20,            height=2        )        submit_btn.pack(side=tk.LEFT, padx=10, pady=5)                # Menu button        menu_btn = tk.Button(            button_frame,            text="Main Menu",            command=self.show_menu,            bg="#e74c3c",            fg="white",            activebackground="#c0392b",            activeforeground="white",            relief=tk.FLAT,            font=self.button_font,            width=20,            height=2        )        menu_btn.pack(side=tk.LEFT, padx=10, pady=5)                self.update_status()    def check_riddle_answer(self, scene: Scene):        """Check if the player's answer to the riddle is correct"""        player_answer = self.answer_entry.get().strip().lower()        correct_answer = self.current_riddle[1].lower()                if player_answer == correct_answer:            messagebox.showinfo("Correct!", "The guards nod in approval.")            self.current_riddle = ("", "")  # Reset for next riddle            self.riddle_attempts = 0            self.process_choice(scene.results[0])  # Move to next riddle or victory        else:            self.riddle_attempts += 1            if self.riddle_attempts >= 3:                messagebox.showerror("Wrong Answer", "The guards grow impatient and attack!")                self.process_choice(scene.results[1])  # Game over            else:                messagebox.showwarning("Wrong Answer", f"Incorrect! You have {3-self.riddle_attempts} attempts remaining.")    def process_choice(self, result: str):        """Process player choice and determine next scene"""        if result == "battle_result_demon_king":            self.handle_battle(is_final_boss=True)        elif result.startswith("battle_"):            self.handle_battle()        else:            # Check if player can afford purchases            scene = self.db.load_scene(self.current_player.progress)            if scene and scene.gold_reward < 0 and self.current_player.gold < -scene.gold_reward:                messagebox.showwarning("Not Enough Gold", "You don't have enough gold for that!")                return                        self.display_scene(result)    def handle_battle(self, is_final_boss=False):        """Handle battle mechanics with number-guessing mini-game"""                    if not self.current_enemy:            print(f"Current scene: {self.current_player.progress}")            messagebox.showerror("Error", "No enemy to fight!")            return                # Generate and store the enemy's number if not already set        if self.current_enemy_number is None:            self.current_enemy_number = random.randint(1,3)                # Create battle window        battle_window = tk.Toplevel(self.root)        battle_window.title("Battle!")        battle_window.geometry("400x300")        battle_window.configure(bg="#2c3e50")        battle_window.resizable(False, False)                # Center the battle window        window_width = battle_window.winfo_reqwidth()        window_height = battle_window.winfo_reqheight()        position_right = int(battle_window.winfo_screenwidth()/2 - window_width/2)        position_down = int(battle_window.winfo_screenheight()/2 - window_height/2)        battle_window.geometry(f"+{position_right}+{position_down}")                # Battle UI        tk.Label(            battle_window,            text=f"BATTLE: {self.current_enemy.name}",            font=self.title_font,            fg="#e74c3c",            bg="#2c3e50"        ).pack(pady=10)                # Stats frame        stats_frame = tk.Frame(battle_window, bg="#2c3e50")        stats_frame.pack(pady=10)                # Player stats        player_frame = tk.Frame(stats_frame, bg="#34495e", padx=10, pady=5)        player_frame.pack(side=tk.LEFT, padx=5)        tk.Label(            player_frame,            text="YOU",            font=("Helvetica", 10, "bold"),            fg="#3498db",            bg="#34495e"        ).pack()        tk.Label(            player_frame,            text=f"? {self.current_player.health}",            fg="#e74c3c",            bg="#34495e"        ).pack()        tk.Label(            player_frame,            text=f"? {self.current_player.attack_power}",            fg="#ecf0f1",            bg="#34495e"        ).pack()                # VS label        tk.Label(            stats_frame,            text="VS",            font=("Helvetica", 12, "bold"),            fg="#f1c40f",            bg="#2c3e50"        ).pack(side=tk.LEFT, padx=10)                # Enemy stats        enemy_frame = tk.Frame(stats_frame, bg="#34495e", padx=10, pady=5)        enemy_frame.pack(side=tk.LEFT, padx=5)        tk.Label(            enemy_frame,            text=self.current_enemy.name.upper(),            font=("Helvetica", 10, "bold"),            fg="#e74c3c",            bg="#34495e"        ).pack()        tk.Label(            enemy_frame,            text=f"? {self.current_enemy.health}",            fg="#e74c3c",            bg="#34495e"        ).pack()        tk.Label(            enemy_frame,            text=f"? {self.current_enemy.attack_power}",            fg="#ecf0f1",            bg="#34495e"        ).pack()                # Number guessing game        tk.Label(            battle_window,            text="Guess a number (1-3) to attack:",            font=self.text_font,            fg="#ecf0f1",            bg="#2c3e50"        ).pack(pady=10)                # Number entry        number_entry = tk.Entry(            battle_window,            font=self.text_font,            width=3,            justify="center"        )        number_entry.pack()                # Result label        result_label = tk.Label(            battle_window,            text="",            font=self.text_font,            fg="#ecf0f1",            bg="#2c3e50"        )        result_label.pack(pady=10)                def process_attack():            """Process the player's attack attempt"""            try:                player_guess = int(number_entry.get())                if player_guess < 1 or player_guess > 3:                    raise ValueError                                # Use the stored enemy number                enemy_number = self.current_enemy_number                                if player_guess == enemy_number:                    # Successful attack                    damage = self.current_player.attack_power * 3                    self.current_enemy.health -= damage                    result_label.config(                        text=f"You guessed correctly! {damage} damage dealt!",                        fg="#2ecc71"                    )                                        # Reset the enemy number for next attack                    self.current_enemy_number = None                                        # Check if enemy is defeated                    if self.current_enemy.health <= 0:                        battle_window.destroy()                        self.enemy_defeated(is_final_boss)                        return                else:                    # Failed attack - enemy counterattacks                    damage = max(1, self.current_enemy.attack_power - (self.current_player.defense // 3))                    self.current_player.health -= damage                    result_label.config(                        text=f"You guessed wrong! The enemy attacks for {damage} damage!\n",                        fg="#e74c3c"                    )                                        # Check if player is defeated                    if self.current_player.health <= 0:                        battle_window.destroy()                        self.display_scene("game_over")                        return                                # Update stats                tk.Label(                    player_frame,                    text=f"? {self.current_player.health}",                    fg="#e74c3c" if self.current_player.health < 30 else "#ecf0f1",                    bg="#34495e"                ).pack()                                tk.Label(                    enemy_frame,                    text=f"? {self.current_enemy.health}",                    fg="#e74c3c",                    bg="#34495e"                ).pack()                                # Clear entry for next guess                number_entry.delete(0, tk.END)                            except ValueError:                messagebox.showerror("Invalid Input", "Please enter a number between 1 and 5")                number_entry.delete(0, tk.END)                # Attack button        tk.Button(            battle_window,            text="ATTACK!",            command=process_attack,            bg="#e74c3c",            fg="white",            activebackground="#c0392b",            activeforeground="white",            relief=tk.FLAT,            font=self.button_font        ).pack(pady=10)                # Make the battle window modal        battle_window.grab_set()        self.root.wait_window(battle_window)        def enemy_defeated(self, is_final_boss):        """Handle enemy defeat"""        # Reset the enemy number        self.current_enemy_number = None                message = f"You defeated the {self.current_enemy.name}!"                # Handle loot        if self.current_enemy.loot:            loot_items = []            for item_name in self.current_enemy.loot:                item = self.db.load_item(item_name)                if item:                    self.current_player.inventory.append(item.name)                    loot_items.append(item.name)                        if loot_items:                message += f"\n\nYou found: {', '.join(loot_items)}"                # Add gold reward        self.current_player.gold += self.current_enemy.gold_reward        message += f"\n\nYou gained {self.current_enemy.gold_reward} gold!"                # Track demons defeated        if "demon" in self.current_enemy.name.lower():            self.current_player.demons_defeated += 1                # Special victory for final boss        if is_final_boss:            messagebox.showinfo("VICTORY!", "You have defeated the Demon King and saved the kingdom!")            self.display_scene("victory")            return                messagebox.showinfo("Victory!", message)                # Clear current enemy after defeat        self.current_enemy = None                # Move to next scene        current_scene = self.db.load_scene(self.current_player.progress)        if current_scene and current_scene.results:            self.display_scene(current_scene.results[0])        else:            self.display_scene("village_square")  # Default fallback# Run the gameif __name__ == "__main__":    # Create images directory if it doesn't exist    if not os.path.exists("images"):        os.makedirs("images")        root = tk.Tk()    game = GameWindow(root)    root.mainloop()